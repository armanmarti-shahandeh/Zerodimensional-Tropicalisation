@doc raw"""
    tropical_variety_zerodimensional(I::MPolyIdeal{<:Generic.MPoly{<:Generic.RationalFunctionFieldElem}}, nu::TropicalSemiringMap; precision::Int=8, precisionStep::Int=4)

Return the tropical variety of `I` with respect to `nu`.  Assumes that
- `I` is zero-dimensional
- `I` is defined over a rational function field
- `nu` encodes the `t`-adic valuation

Optional parameters:

- `precision`: The beginning max relative precision up to which roots may be computed.
- `precisionStep`: The amount by which to increase the max relative precision if necessary.

# Examples
```jldoctest
julia> K,t = rational_function_field(GF(3),:t);

julia> nu = tropical_semiring_map(K,t)
Map into Min tropical semiring encoding the t-adic valuation on Rational function field over GF(3)

julia> Kx,(x1,x2) = polynomial_ring(K,[:x1,:x2]);

julia> f1 = (x1+(1+2*t+t^2))*(x1+(1+2*t+t^3));

julia> f2 = x2 - (x1+1+2*t);

julia> I = ideal([f1,f2])
Ideal generated by
  x1^2 + (t^3 + t^2 + t + 2)*x1 + t^5 + 2*t^4 + 2*t^2 + t + 1
  2*x1 + x2 + t + 2

julia> TropI = tropical_variety_zerodimensional(I,nu)
Min tropical variety

julia> dim(TropI)
0

julia> vertices(TropI)
2-element SubObjectIterator{PointVector{QQFieldElem}}:
 [0, 2]
 [0, 3]
```
"""
function tropical_variety_zerodimensional(I::MPolyIdeal{<:Generic.MPoly{<:Generic.RationalFunctionFieldElem}}, nu::TropicalSemiringMap; precision::Int=8, precisionStep::Int=4)
    @req coefficient_ring(I) == domain(nu) "coefficient ring of input ideal must match tropical semiring map domain"
    @req domain(nu)(uniformizer(nu)) == gen(domain(nu)) "tropical semiring map must encode t-adic valuation"

    Sigma = Vector{QQFieldElem}[]
    for F in triangular_decomposition(I; algorithm=:lazard_factorized, ord=gens(base_ring(I)))
        Sigma = vcat(Sigma, tropical_points_triangular(F, nu; precision=precision, precisionStep=precisionStep))
    end
    Sigma = unique(sort(Sigma))
    TropI = tropical_variety(polyhedral_complex(incidence_matrix([[i] for i in 1:length(Sigma)]),Sigma),
                             ones(ZZRingElem,length(Sigma)))
    return TropI
end

# check whether the polynomials in F are lower triangular,
# i.e., F[1] is a polynomial in x1, F[2] is a polynomial in x1 and x2, etc.
function is_lower_triangular(F::Vector{<:MPolyRingElem})
    for (i,f) in enumerate(F)
        # sum all exponent vectors. check that entry i is non-zero and entries after i are zero
        Alpha = sum(exponents(f), init=zeros(ZZRingElem, ngens(parent(f))))
        if Alpha[i] == 0
            return false
        end
        if any(!iszero,Alpha[i+1:end])
            return false
        end
    end
    return true
end

function create_m_puiseux_polynomial_ring(Kt::Generic.RationalFunctionField)
    K = base_ring(Kt)
    tString = string(gen(Kt))
    L = algebraic_closure(K)
    Lt, _ = puiseux_polynomial_ring(L, [tString])
    return Lt
end

function rational_function_to_puiseux_polynomial(c::Generic.RationalFunctionFieldElem, Lt::MPuiseuxPolyRing)
    @req isone(denominator(c)) "denominator of rational function must be 1"
    c = numerator(c)
    t = first(gens(Lt))
    d = zero(Lt)
    for (i, ci) in enumerate(coefficients(c))
        d += t^i * Lt(ci)
    end
    return d
end

function prep_for_tropical_points_triangular(F::Vector{<:MPolyRingElem})
    F = [ f*lcm(denominator.(coefficients(f))) for f in F ] # clear denominators

    Ktx = parent(F[1])
    Kt = base_ring(Ktx)
    Lt = create_m_puiseux_polynomial_ring(Kt)
    Ltx, x = polynomial_ring(Lt, symbols(Ktx))

    homPrep = hom(Ktx, Ltx, c->rational_function_to_puiseux_polynomial(c, Lt), x)
    return homPrep.(F)
end


@doc raw"""
    tropical_points_triangular(I::MPolyIdeal{<:Generic.MPoly{<:Generic.RationalFunctionFieldElem}}, nu::TropicalSemiringMap; precision::Int=8, precisionStep::Int=4)

Return the points in the tropical variety of `I` with respect to `nu`.  Assumes
that

- `I` is generated by a triangular set (first generator univariate in first
  variable, second generator bivariate in first two variables, etc.).
- `I` is defined over a rational function field.
- `nu` encodes the `t`-adic valuation.

Optional parameters:

- `precision`: The beginning max relative precision up to which roots may be computed.
- `precisionStep`: The amount by which to increase the max relative precision if necessary.

# Examples
```jldoctest
julia> K,t = rational_function_field(GF(3),:t);

julia> nu = tropical_semiring_map(K,t)
Map into Min tropical semiring encoding the t-adic valuation on Rational function field over GF(3)

julia> Kx,(x1,x2) = polynomial_ring(K,[:x1,:x2]);

julia> f1 = (x1+(1+2*t+t^2))*(x1+(1+2*t+t^3));

julia> f2 = x2 - (x1+1+2*t);

julia> I = ideal([f1,f2])
Ideal generated by
  x1^2 + (t^3 + t^2 + t + 2)*x1 + t^5 + 2*t^4 + 2*t^2 + t + 1
  2*x1 + x2 + t + 2

julia> tropical_points_triangular(I, nu)
2-element Vector{Vector{QQFieldElem}}:
 [0, 2]
 [0, 3]
```
"""
function tropical_points_triangular(I::MPolyIdeal{<:Generic.MPoly{<:Generic.RationalFunctionFieldElem}}, nu::TropicalSemiringMap; precision::Int=8, precisionStep::Int=4)
    # check that generators are triangular set and prep for root tree
    triangularSet = gens(I)
    @req is_lower_triangular(triangularSet) "Generators of input ideal must be lower triangular."
    triangularSet = prep_for_tropical_points_triangular(triangularSet)

    # initialize root tree
    Gamma = root_tree(triangularSet, QQ(precision), QQ(precisionStep))
    @vprintln :ZerodimensionalTropicalization "Starting root tree:\n$(Gamma)"

    # grow root tree
    leafToGrow = 1
    while leafToGrow>0
        growthSuccessful = grow!(Gamma,leafToGrow)
        if !growthSuccessful
            reinforce!(Gamma,leafToGrow)
        end
        @vprintln :ZerodimensionalTropicalization "Updated root tree:\n$(Gamma)"
        leafToGrow = pick_ungrown_leaf(Gamma)
    end

    # extract and return tropical points
    return convention(nu)==min ? tropical_points(Gamma) : -tropical_points(Gamma)
end
